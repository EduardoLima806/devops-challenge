name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: devops-challenge
  TERRAFORM_VERSION: 1.5.0
  PYTHON_VERSION: '3.11'

jobs:
  lint-and-test:
    name: Lint and Test
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install flake8 black isort mypy
      
      - name: Run code formatting check (Black)
        run: black --check app.py tests/
        continue-on-error: true
      
      - name: Run import sorting check (isort)
        run: isort --check-only app.py tests/
        continue-on-error: true
      
      - name: Run linting (Flake8)
        run: |
          flake8 app.py tests/ --max-line-length=100 --extend-ignore=E203,W503 || true
        continue-on-error: true
      
      - name: Run type checking (mypy)
        run: |
          pip install types-all
          mypy app.py --ignore-missing-imports || true
        continue-on-error: true
      
      - name: Run unit tests
        if: github.event.inputs.skip_tests != 'true'
        run: |
          pytest tests/ -v --cov=app --cov-report=xml --cov-report=term
      
      - name: Upload coverage reports
        if: github.event.inputs.skip_tests != 'true'
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: lint-and-test
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      ecr-repository: ${{ steps.ecr.outputs.repository }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          tags: |
            type=sha,prefix={{branch}}-
            type=sha,format=short
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ github.run_number }}
            type=raw,value=${{ github.ref_name }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=registry,ref=${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:buildcache
          cache-to: type=registry,ref=${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:buildcache,mode=max
          platforms: linux/amd64
      
      - name: Save image metadata
        id: image
        run: |
          ECR_REGISTRY=${{ steps.ecr.outputs.registry }}
          ECR_REPO="$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}"
          SHA_TAG=$(echo "${{ github.sha }}" | cut -c1-7)
          FULL_TAG="$ECR_REPO:$SHA_TAG"
          
          echo "sha-tag=$SHA_TAG" >> $GITHUB_OUTPUT
          echo "full-image-tag=$FULL_TAG" >> $GITHUB_OUTPUT
          echo "ecr-repo=$ECR_REPO" >> $GITHUB_OUTPUT
          echo "image-digest=${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
      
      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init -input=false
      
      - name: Terraform Validate
        working-directory: ./terraform
        run: terraform validate
      
      - name: Terraform Format Check
        working-directory: ./terraform
        run: terraform fmt -check -recursive
      
      - name: Terraform Plan
        id: plan
        working-directory: ./terraform
        run: |
          terraform plan -out=tfplan -input=false
          terraform show -json tfplan > tfplan.json
      
      - name: Comment PR with Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const plan = fs.readFileSync('terraform/tfplan.json', 'utf8');
            const output = `## Terraform Plan ðŸ“‹
            \`\`\`
            ${plan}
            \`\`\`
            `;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })
      
      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v3
        with:
          name: terraform-plan
          path: terraform/tfplan
          retention-days: 5

  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    needs: [build-and-push, terraform-plan]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment:
      name: production
      url: ${{ steps.deploy-info.outputs.url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Download Terraform Plan
        uses: actions/download-artifact@v3
        with:
          name: terraform-plan
          path: terraform/
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
      
      - name: Terraform Apply
        working-directory: ./terraform
        run: terraform apply -input=false tfplan
      
      - name: Get ECS Cluster and Service names
        id: ecs-info
        run: |
          CLUSTER_NAME=$(terraform -chdir=terraform output -raw ecs_cluster_id 2>/dev/null || echo "devops-challenge-dev-cluster")
          SERVICE_NAME=$(terraform -chdir=terraform output -raw ecs_service_name 2>/dev/null || echo "devops-challenge-dev-service")
          echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          echo "cluster=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "service=$SERVICE_NAME" >> $GITHUB_OUTPUT
      
      - name: Get current task definition
        id: current-task-def
        run: |
          TASK_DEF=$(aws ecs describe-services \
            --cluster ${{ env.CLUSTER_NAME }} \
            --services ${{ env.SERVICE_NAME }} \
            --query 'services[0].taskDefinition' \
            --output text)
          echo "TASK_DEF=$TASK_DEF" >> $GITHUB_ENV
          echo "task-def=$TASK_DEF" >> $GITHUB_OUTPUT
      
      - name: Update ECS service with new image
        id: update-service
        run: |
          # Get the image tag from previous job
          SHA_TAG="${{ needs.build-and-push.outputs.sha-tag }}"
          ECR_REPO="${{ needs.build-and-push.outputs.ecr-repo }}"
          IMAGE_URI="$ECR_REPO:$SHA_TAG"
          
          echo "Deploying image: $IMAGE_URI"
          
          # Get current task definition
          TASK_DEF_ARN=${{ steps.current-task-def.outputs.task-def }}
          TASK_DEF_FAMILY=$(echo $TASK_DEF_ARN | cut -d'/' -f2 | cut -d':' -f1)
          
          # Get task definition JSON
          aws ecs describe-task-definition \
            --task-definition $TASK_DEF_ARN \
            --query 'taskDefinition' > task-definition.json
          
          # Update image in task definition
          python3 << EOF
          import json
          with open('task-definition.json', 'r') as f:
              task_def = json.load(f)
          
          # Remove fields that can't be updated
          for field in ['taskDefinitionArn', 'revision', 'status', 'requiresAttributes', 'compatibilities', 'registeredAt', 'registeredBy']:
              task_def.pop(field, None)
          
          # Update container image
          task_def['containerDefinitions'][0]['image'] = '$IMAGE_URI'
          
          # Save updated task definition
          with open('new-task-definition.json', 'w') as f:
              json.dump(task_def, f, indent=2)
          EOF
          
          # Register new task definition
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "NEW_TASK_DEF=$NEW_TASK_DEF" >> $GITHUB_ENV
          echo "new-task-def=$NEW_TASK_DEF" >> $GITHUB_OUTPUT
          echo "old-task-def=$TASK_DEF_ARN" >> $GITHUB_OUTPUT
      
      - name: Deploy to ECS
        id: deploy
        run: |
          # Update ECS service
          aws ecs update-service \
            --cluster ${{ env.CLUSTER_NAME }} \
            --service ${{ env.SERVICE_NAME }} \
            --task-definition ${{ steps.update-service.outputs.new-task-def }} \
            --force-new-deployment \
            --query 'service.serviceName' \
            --output text
          
          echo "Deployment initiated. Waiting for service to stabilize..."
      
      - name: Wait for service to stabilize
        id: wait
        run: |
          MAX_WAIT=600  # 10 minutes
          ELAPSED=0
          INTERVAL=30
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            STATUS=$(aws ecs describe-services \
              --cluster ${{ env.CLUSTER_NAME }} \
              --services ${{ env.SERVICE_NAME }} \
              --query 'services[0].deployments[?status==`PRIMARY`].runningCount' \
              --output text)
            
            DESIRED=$(aws ecs describe-services \
              --cluster ${{ env.CLUSTER_NAME }} \
              --services ${{ env.SERVICE_NAME }} \
              --query 'services[0].desiredCount' \
              --output text)
            
            if [ "$STATUS" = "$DESIRED" ] && [ "$STATUS" != "0" ]; then
              echo "Service is stable with $STATUS/$DESIRED tasks running"
              echo "deployment-success=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            echo "Waiting for service to stabilize... ($STATUS/$DESIRED tasks running, elapsed: ${ELAPSED}s)"
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          echo "Service did not stabilize within $MAX_WAIT seconds"
          echo "deployment-success=false" >> $GITHUB_OUTPUT
          exit 1
      
      - name: Health check after deployment
        id: health-check
        if: steps.wait.outputs.deployment-success == 'true'
        run: |
          ALB_DNS=$(terraform -chdir=terraform output -raw alb_dns_name 2>/dev/null || echo "")
          if [ -z "$ALB_DNS" ]; then
            echo "ALB DNS not available, skipping health check"
            exit 0
          fi
          
          MAX_RETRIES=10
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 http://$ALB_DNS/health || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "Health check passed!"
              echo "health-check-passed=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Health check failed (HTTP $HTTP_CODE), retrying... ($RETRY_COUNT/$MAX_RETRIES)"
            sleep 10
          done
          
          echo "Health check failed after $MAX_RETRIES attempts"
          echo "health-check-passed=false" >> $GITHUB_OUTPUT
          exit 1
      
      - name: Rollback on failure
        if: failure() || steps.wait.outputs.deployment-success == 'false' || steps.health-check.outputs.health-check-passed == 'false'
        run: |
          echo "Deployment failed. Initiating rollback..."
          
          OLD_TASK_DEF=${{ steps.update-service.outputs.old-task-def }}
          
          # Update service back to previous task definition
          aws ecs update-service \
            --cluster ${{ env.CLUSTER_NAME }} \
            --service ${{ env.SERVICE_NAME }} \
            --task-definition $OLD_TASK_DEF \
            --force-new-deployment \
            --query 'service.serviceName' \
            --output text
          
          echo "Rollback initiated. Service is reverting to previous task definition."
          echo "Please check CloudWatch logs and ECS service events for details."
          
          exit 1
      
      - name: Deployment info
        id: deploy-info
        if: steps.wait.outputs.deployment-success == 'true'
        run: |
          ALB_DNS=$(terraform -chdir=terraform output -raw alb_dns_name 2>/dev/null || echo "")
          if [ -n "$ALB_DNS" ]; then
            echo "url=http://$ALB_DNS" >> $GITHUB_OUTPUT
            echo "Application deployed successfully!"
            echo "Health endpoint: http://$ALB_DNS/health"
            echo "API endpoint: http://$ALB_DNS/api/hello"
          fi
